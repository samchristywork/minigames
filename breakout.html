<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background: #0f0f23;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 4px solid #ffcc00;
            border-radius: 8px;
            background: #1a1a2e;
        }
        #hud {
            display: flex;
            gap: 40px;
            color: #ffcc00;
            font-size: 20px;
            margin-bottom: 16px;
        }
        #instructions {
            color: #aaa;
            margin-top: 16px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="hud">
        <div id="score">Score: 0</div>
        <div id="lives">Lives: 3</div>
    </div>
    <canvas id="game" width="480" height="400"></canvas>
    <div id="instructions">Move mouse or use A/D keys. Click or press Space to launch ball.</div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');

        // Paddle
        const paddle = {
            width: 80,
            height: 12,
            x: 200,
            y: canvas.height - 30,
            speed: 8,
            dx: 0
        };

        // Ball
        let ball = {
            x: canvas.width / 2,
            y: paddle.y - 10,
            radius: 8,
            speed: 5,
            dx: 0,
            dy: 0,
            launched: false
        };

        // Bricks
        const brickConfig = {
            rows: 5,
            cols: 8,
            width: 50,
            height: 20,
            padding: 8,
            offsetTop: 40,
            offsetLeft: 28
        };

        const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#1dd1a1', '#ff9ff3'];
        let bricks = [];
        let score = 0;
        let lives = 3;
        let gameOver = false;
        let won = false;

        function createBricks() {
            bricks = [];
            for (let row = 0; row < brickConfig.rows; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    bricks.push({
                        x: col * (brickConfig.width + brickConfig.padding) + brickConfig.offsetLeft,
                        y: row * (brickConfig.height + brickConfig.padding) + brickConfig.offsetTop,
                        width: brickConfig.width,
                        height: brickConfig.height,
                        color: colors[row],
                        alive: true,
                        points: (brickConfig.rows - row) * 10
                    });
                }
            }
        }

        function resetBall() {
            ball.x = paddle.x + paddle.width / 2;
            ball.y = paddle.y - ball.radius;
            ball.dx = 0;
            ball.dy = 0;
            ball.launched = false;
        }

        function launchBall() {
            if (!ball.launched && !gameOver) {
                ball.launched = true;
                ball.dx = (Math.random() - 0.5) * 4;
                ball.dy = -ball.speed;
            }
        }

        function init() {
            score = 0;
            lives = 3;
            gameOver = false;
            won = false;
            paddle.x = canvas.width / 2 - paddle.width / 2;
            createBricks();
            resetBall();
            updateHUD();
        }

        function updateHUD() {
            scoreEl.textContent = `Score: ${score}`;
            livesEl.textContent = `Lives: ${lives}`;
        }

        function update() {
            if (gameOver) return;

            // Move paddle
            paddle.x += paddle.dx;
            paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));

            // Ball follows paddle before launch
            if (!ball.launched) {
                ball.x = paddle.x + paddle.width / 2;
                return;
            }

            // Move ball
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Wall collisions
            if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= canvas.width) {
                ball.dx *= -1;
            }
            if (ball.y - ball.radius <= 0) {
                ball.dy *= -1;
            }

            // Ball fell
            if (ball.y + ball.radius >= canvas.height) {
                lives--;
                updateHUD();
                if (lives <= 0) {
                    gameOver = true;
                } else {
                    resetBall();
                }
                return;
            }

            // Paddle collision
            if (ball.dy > 0 &&
                ball.y + ball.radius >= paddle.y &&
                ball.y - ball.radius <= paddle.y + paddle.height &&
                ball.x >= paddle.x &&
                ball.x <= paddle.x + paddle.width) {

                ball.dy = -Math.abs(ball.dy);
                // Add angle based on where ball hits paddle
                const hitPos = (ball.x - paddle.x) / paddle.width;
                ball.dx = (hitPos - 0.5) * 8;
            }

            // Brick collisions
            for (const brick of bricks) {
                if (!brick.alive) continue;

                if (ball.x + ball.radius > brick.x &&
                    ball.x - ball.radius < brick.x + brick.width &&
                    ball.y + ball.radius > brick.y &&
                    ball.y - ball.radius < brick.y + brick.height) {

                    brick.alive = false;
                    score += brick.points;
                    updateHUD();

                    // Determine collision side
                    const overlapLeft = ball.x + ball.radius - brick.x;
                    const overlapRight = brick.x + brick.width - (ball.x - ball.radius);
                    const overlapTop = ball.y + ball.radius - brick.y;
                    const overlapBottom = brick.y + brick.height - (ball.y - ball.radius);

                    const minOverlapX = Math.min(overlapLeft, overlapRight);
                    const minOverlapY = Math.min(overlapTop, overlapBottom);

                    if (minOverlapX < minOverlapY) {
                        ball.dx *= -1;
                    } else {
                        ball.dy *= -1;
                    }

                    break;
                }
            }

            // Check win
            if (bricks.every(b => !b.alive)) {
                gameOver = true;
                won = true;
            }
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw bricks
            for (const brick of bricks) {
                if (!brick.alive) continue;
                ctx.fillStyle = brick.color;
                ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
            }

            // Draw paddle
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 6);
            ctx.fill();

            // Draw ball
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();

            // Ball trail effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(ball.x - ball.dx, ball.y - ball.dy, ball.radius * 0.7, 0, Math.PI * 2);
            ctx.fill();

            // Game over / win screen
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.textAlign = 'center';

                if (won) {
                    ctx.fillStyle = '#1dd1a1';
                    ctx.font = 'bold 36px Arial';
                    ctx.fillText('YOU WIN!', canvas.width / 2, canvas.height / 2);
                } else {
                    ctx.fillStyle = '#ff6b6b';
                    ctx.font = 'bold 36px Arial';
                    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                }

                ctx.font = '20px Arial';
                ctx.fillStyle = '#fff';
                ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
                ctx.font = '16px Arial';
                ctx.fillStyle = '#aaa';
                ctx.fillText('Click to play again', canvas.width / 2, canvas.height / 2 + 70);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Mouse controls
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            paddle.x = mouseX - paddle.width / 2;
            paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));
        });

        canvas.addEventListener('click', () => {
            if (gameOver) {
                init();
            } else {
                launchBall();
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
                paddle.dx = -paddle.speed;
            }
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
                paddle.dx = paddle.speed;
            }
            if (e.code === 'Space') {
                if (gameOver) {
                    init();
                } else {
                    launchBall();
                }
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if ((e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') && paddle.dx < 0) {
                paddle.dx = 0;
            }
            if ((e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') && paddle.dx > 0) {
                paddle.dx = 0;
            }
        });

        init();
        gameLoop();
    </script>
</body>
</html>
