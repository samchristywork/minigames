<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doodle Jump</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background: #87ceeb;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }
        canvas {
            border: 4px solid #5a4a3a;
            border-radius: 8px;
            background: #f5f5dc;
        }
        #score-display {
            font-size: 24px;
            color: #5a4a3a;
            margin-bottom: 10px;
        }
        #instructions {
            color: #5a4a3a;
            margin-top: 12px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="score-display">Score: <span id="score">0</span></div>
    <canvas id="game" width="400" height="600"></canvas>
    <div id="instructions">Use arrow keys or A/D to move. Jump on platforms to climb higher!</div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');

        const GRAVITY = 0.25;
        const JUMP_FORCE = -10;
        const MOVE_SPEED = 6;

        let player;
        let platforms = [];
        let score = 0;
        let highScore = 0;
        let gameOver = false;
        let keys = {};
        let cameraY = 0;
        let maxHeight = 0;

        const PLATFORM_TYPES = {
            normal: { color: '#7cb342', breakable: false, moving: false },
            moving: { color: '#42a5f5', breakable: false, moving: true },
            breakable: { color: '#bcaaa4', breakable: true, moving: false },
            spring: { color: '#7cb342', breakable: false, moving: false, spring: true }
        };

        function init() {
            player = {
                x: canvas.width / 2 - 20,
                y: canvas.height - 100,
                width: 40,
                height: 40,
                vx: 0,
                vy: 0,
                facingRight: true
            };

            platforms = [];
            score = 0;
            gameOver = false;
            cameraY = 0;
            maxHeight = 0;

            // Starting platform
            platforms.push({
                x: canvas.width / 2 - 40,
                y: canvas.height - 50,
                width: 80,
                height: 15,
                type: 'normal',
                ...PLATFORM_TYPES.normal
            });

            // Generate initial platforms
            for (let y = canvas.height - 100; y > -200; y -= 60 + Math.random() * 40) {
                spawnPlatform(y);
            }

            scoreEl.textContent = '0';
        }

        function spawnPlatform(y) {
            const x = Math.random() * (canvas.width - 80);

            // Determine platform type
            let type = 'normal';
            const rand = Math.random();

            if (score > 500 && rand < 0.15) {
                type = 'breakable';
            } else if (score > 200 && rand < 0.25) {
                type = 'moving';
            } else if (rand < 0.08) {
                type = 'spring';
            }

            const platform = {
                x: x,
                y: y,
                width: 70 + Math.random() * 20,
                height: 15,
                type: type,
                ...PLATFORM_TYPES[type],
                moveDir: Math.random() < 0.5 ? 1 : -1,
                broken: false
            };

            platforms.push(platform);
        }

        function update() {
            if (gameOver) return;

            // Horizontal movement
            if (keys['ArrowLeft'] || keys['KeyA']) {
                player.vx = -MOVE_SPEED;
                player.facingRight = false;
            } else if (keys['ArrowRight'] || keys['KeyD']) {
                player.vx = MOVE_SPEED;
                player.facingRight = true;
            } else {
                player.vx *= 0.85;
            }

            // Apply gravity
            player.vy += GRAVITY;

            // Move player
            player.x += player.vx;
            player.y += player.vy;

            // Screen wrapping
            if (player.x + player.width < 0) {
                player.x = canvas.width;
            } else if (player.x > canvas.width) {
                player.x = -player.width;
            }

            // Move moving platforms
            for (const platform of platforms) {
                if (platform.moving) {
                    platform.x += platform.moveDir * 2;
                    if (platform.x <= 0 || platform.x + platform.width >= canvas.width) {
                        platform.moveDir *= -1;
                    }
                }
            }

            // Platform collision (only when falling)
            if (player.vy > 0) {
                for (const platform of platforms) {
                    if (platform.broken) continue;

                    const playerBottom = player.y + player.height;
                    const playerPrevBottom = playerBottom - player.vy;

                    if (playerBottom >= platform.y &&
                        playerPrevBottom <= platform.y + 5 &&
                        player.x + player.width - 10 > platform.x &&
                        player.x + 10 < platform.x + platform.width) {

                        if (platform.breakable) {
                            platform.broken = true;
                        } else if (platform.spring) {
                            player.vy = JUMP_FORCE * 1.8;
                        } else {
                            player.vy = JUMP_FORCE;
                        }
                        player.y = platform.y - player.height;
                    }
                }
            }

            // Update camera and score
            const playerScreenY = player.y - cameraY;
            if (playerScreenY < canvas.height * 0.4) {
                const diff = canvas.height * 0.4 - playerScreenY;
                cameraY -= diff;

                // Update max height and score
                const height = -player.y;
                if (height > maxHeight) {
                    score += Math.floor(height - maxHeight);
                    maxHeight = height;
                    scoreEl.textContent = score;
                }

                // Generate new platforms
                const topY = cameraY - 100;
                const highestPlatform = Math.min(...platforms.map(p => p.y));
                if (highestPlatform > topY) {
                    const gap = 60 + Math.random() * 40 - Math.min(score / 100, 20);
                    spawnPlatform(highestPlatform - gap);
                }

                // Remove platforms below screen
                platforms = platforms.filter(p => p.y < cameraY + canvas.height + 50);
            }

            // Game over if player falls below screen
            if (player.y - cameraY > canvas.height) {
                gameOver = true;
                if (score > highScore) {
                    highScore = score;
                }
            }
        }

        function drawPlayer() {
            const screenY = player.y - cameraY;
            const x = player.x;

            ctx.save();

            if (!player.facingRight) {
                ctx.translate(x + player.width, 0);
                ctx.scale(-1, 1);
                ctx.translate(-x, 0);
            }

            // Body
            ctx.fillStyle = '#90ee90';
            ctx.beginPath();
            ctx.ellipse(x + player.width/2, screenY + player.height/2, player.width/2.2, player.height/2.2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Snout
            ctx.fillStyle = '#98fb98';
            ctx.beginPath();
            ctx.ellipse(x + player.width - 5, screenY + player.height/2, 12, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eye
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(x + player.width - 10, screenY + player.height/3, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x + player.width - 6, screenY + player.height/3, 4, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#90ee90';
            if (player.vy < 0) {
                // Jumping - legs down
                ctx.fillRect(x + 8, screenY + player.height - 5, 8, 12);
                ctx.fillRect(x + player.width - 16, screenY + player.height - 5, 8, 12);
            } else {
                // Falling - legs up
                ctx.fillRect(x + 5, screenY + player.height - 10, 10, 8);
                ctx.fillRect(x + player.width - 15, screenY + player.height - 10, 10, 8);
            }

            // Feet
            ctx.fillStyle = '#7ccd7c';
            ctx.fillRect(x + 4, screenY + player.height + (player.vy < 0 ? 5 : -5), 14, 5);
            ctx.fillRect(x + player.width - 18, screenY + player.height + (player.vy < 0 ? 5 : -5), 14, 5);

            ctx.restore();
        }

        function drawPlatform(platform) {
            const screenY = platform.y - cameraY;

            if (platform.broken) {
                // Draw broken pieces falling
                ctx.fillStyle = '#8d6e63';
                ctx.save();
                ctx.translate(platform.x + platform.width/2, screenY);
                ctx.rotate(platform.brokenAngle || 0);
                ctx.fillRect(-15, 0, 30, 8);
                ctx.restore();
                platform.brokenAngle = (platform.brokenAngle || 0) + 0.1;
                platform.y += 5;
                return;
            }

            // Main platform
            ctx.fillStyle = platform.color;
            ctx.beginPath();
            ctx.roundRect(platform.x, screenY, platform.width, platform.height, 5);
            ctx.fill();

            // Grass/texture on top
            ctx.fillStyle = platform.type === 'breakable' ? '#a1887f' : '#8bc34a';
            ctx.beginPath();
            ctx.roundRect(platform.x, screenY, platform.width, 6, [5, 5, 0, 0]);
            ctx.fill();

            // Spring
            if (platform.spring) {
                ctx.fillStyle = '#ff5722';
                ctx.fillRect(platform.x + platform.width/2 - 8, screenY - 15, 16, 15);
                ctx.fillStyle = '#ffab91';
                ctx.fillRect(platform.x + platform.width/2 - 6, screenY - 12, 12, 3);
                ctx.fillRect(platform.x + platform.width/2 - 6, screenY - 6, 12, 3);
            }

            // Moving platform indicator
            if (platform.moving) {
                ctx.fillStyle = '#1e88e5';
                ctx.beginPath();
                ctx.moveTo(platform.x + platform.width/2 - 10, screenY + 8);
                ctx.lineTo(platform.x + platform.width/2, screenY + 12);
                ctx.lineTo(platform.x + platform.width/2 + 10, screenY + 8);
                ctx.fill();
            }
        }

        function draw() {
            // Background gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#e8f5e9');
            gradient.addColorStop(1, '#f5f5dc');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid lines (notebook effect)
            ctx.strokeStyle = 'rgba(200, 200, 255, 0.3)';
            ctx.lineWidth = 1;
            for (let y = 0; y < canvas.height; y += 30) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw platforms
            for (const platform of platforms) {
                drawPlatform(platform);
            }

            // Draw player
            if (!gameOver) {
                drawPlayer();
            }

            // Score display
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.font = 'bold 20px Comic Sans MS, cursive';
            ctx.textAlign = 'left';
            ctx.fillText(`High: ${highScore}`, 10, 30);

            // Game over screen
            if (gameOver) {
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 40px Comic Sans MS, cursive';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over!', canvas.width/2, canvas.height/2 - 40);

                ctx.font = '24px Comic Sans MS, cursive';
                ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2 + 10);
                ctx.fillText(`Best: ${highScore}`, canvas.width/2, canvas.height/2 + 45);

                ctx.font = '18px Comic Sans MS, cursive';
                ctx.fillStyle = '#aaa';
                ctx.fillText('Press Space to restart', canvas.width/2, canvas.height/2 + 90);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            if (e.code === 'Space' && gameOver) {
                init();
            }

            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Space'].includes(e.code)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        init();
        gameLoop();
    </script>
</body>
</html>
